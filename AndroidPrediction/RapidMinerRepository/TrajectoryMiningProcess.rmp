<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<process version="5.3.005">
  <context>
    <input/>
    <output/>
    <macros/>
  </context>
  <operator activated="true" class="process" compatibility="5.3.005" expanded="true" name="Process">
    <parameter key="logverbosity" value="init"/>
    <parameter key="random_seed" value="2001"/>
    <parameter key="send_mail" value="never"/>
    <parameter key="notification_email" value=""/>
    <parameter key="process_duration_for_mail" value="30"/>
    <parameter key="encoding" value="SYSTEM"/>
    <parameter key="parallelize_main_process" value="false"/>
    <process expanded="true">
      <operator activated="true" class="retrieve" compatibility="5.3.005" expanded="true" height="60" name="Retrieve DummyCells" width="90" x="45" y="30">
        <parameter key="repository_entry" value="//AndroidTrajectoryMining/DummyCells"/>
      </operator>
      <operator activated="false" class="r:execute_script_r" compatibility="5.3.000" expanded="true" height="60" name="3rd order markov transformation" width="90" x="313" y="210">
        <parameter key="script" value="# transform state series (one observation per line) into third order markov form&#10;# throws away first two observations as it is not important for transition probs&#10;# that is:&#10;# 1&#9;&#9;1 - - -&#10;# 2&#9;&#9;1 2 - -&#10;# 3  --&gt;&#9;3 2 1 -&#10;# 4&#9;&#9;4 3 2 1&#10;# 5&#9;&#9;5 4 3 2&#10;t1 = data&#10;t2 = data&#10;t3 = data&#10;for (i in 4:(dim(data)[1])) {&#10;&#9;t1[i,]=data[i-1,]&#10;&#9;t2[i,]=data[i-2,]&#10;&#9;t3[i,]=data[i-3,]&#10;}&#10;result = data.frame(data,t1,t2,t3)&#10;result = result[2:dim(data)[1],]&#10;names(result) = c(&quot;tn&quot;,&quot;tn-1&quot;,&quot;tn-2&quot;,&quot;tn-3&quot;)&#10;result.label = &quot;tn&quot;"/>
        <enumeration key="inputs">
          <parameter key="name_of_variable" value="data"/>
        </enumeration>
        <list key="results">
          <parameter key="result" value="Data Table"/>
        </list>
      </operator>
      <operator activated="false" class="r:execute_script_r" compatibility="5.3.000" expanded="true" height="60" name="2nd order markov transformation" width="90" x="313" y="120">
        <parameter key="script" value="# transform state series (one observation per line) into second order markov form&#10;# throws away first two observations as it is not important for transition probs&#10;# that is:&#10;# 1&#9;&#9;1 - -&#10;# 2&#9;&#9;1 2 -&#10;# 3  --&gt;&#9;3 2 1&#10;# 4&#9;&#9;4 3 2&#10;# 5&#9;&#9;5 4 3&#10;t1 = data&#10;t2 = data&#10;for (i in 4:(dim(data)[1])) {&#10;&#9;t1[i,]=data[i-1,]&#10;&#9;t2[i,]=data[i-2,]&#10;}&#10;result = data.frame(data,t1,t2)&#10;result = result[2:dim(data)[1],]&#10;names(result) = c(&quot;tn&quot;,&quot;tn-1&quot;,&quot;tn-2&quot;)&#10;result.label = &quot;tn&quot;"/>
        <enumeration key="inputs">
          <parameter key="name_of_variable" value="data"/>
        </enumeration>
        <list key="results">
          <parameter key="result" value="Data Table"/>
        </list>
      </operator>
      <operator activated="true" class="generate_data" compatibility="5.3.005" expanded="true" height="60" name="Generate Data" width="90" x="45" y="435">
        <parameter key="target_function" value="sum"/>
        <parameter key="number_examples" value="10"/>
        <parameter key="number_of_attributes" value="1"/>
        <parameter key="attributes_lower_bound" value="0.0"/>
        <parameter key="attributes_upper_bound" value="10.0"/>
        <parameter key="use_local_random_seed" value="false"/>
        <parameter key="local_random_seed" value="1992"/>
        <parameter key="datamanagement" value="int_array"/>
      </operator>
      <operator activated="true" class="select_attributes" compatibility="5.3.005" expanded="true" height="76" name="Select Attributes" width="90" x="45" y="345">
        <parameter key="attribute_filter_type" value="single"/>
        <parameter key="attribute" value="att1"/>
        <parameter key="attributes" value=""/>
        <parameter key="use_except_expression" value="false"/>
        <parameter key="value_type" value="attribute_value"/>
        <parameter key="use_value_type_exception" value="false"/>
        <parameter key="except_value_type" value="time"/>
        <parameter key="block_type" value="attribute_block"/>
        <parameter key="use_block_type_exception" value="false"/>
        <parameter key="except_block_type" value="value_matrix_row_start"/>
        <parameter key="invert_selection" value="false"/>
        <parameter key="include_special_attributes" value="true"/>
      </operator>
      <operator activated="true" class="numerical_to_polynominal" compatibility="5.3.005" expanded="true" height="76" name="Numerical to Polynominal" width="90" x="45" y="255">
        <parameter key="attribute_filter_type" value="all"/>
        <parameter key="attribute" value=""/>
        <parameter key="attributes" value=""/>
        <parameter key="use_except_expression" value="false"/>
        <parameter key="value_type" value="numeric"/>
        <parameter key="use_value_type_exception" value="false"/>
        <parameter key="except_value_type" value="real"/>
        <parameter key="block_type" value="value_series"/>
        <parameter key="use_block_type_exception" value="false"/>
        <parameter key="except_block_type" value="value_series_end"/>
        <parameter key="invert_selection" value="false"/>
        <parameter key="include_special_attributes" value="false"/>
      </operator>
      <operator activated="true" class="multiply" compatibility="5.3.005" expanded="true" height="112" name="Multiply" width="90" x="179" y="30"/>
      <operator activated="true" class="r:execute_script_r" compatibility="5.3.000" expanded="true" height="76" name="Execute Script (R)" width="90" x="313" y="300">
        <parameter key="script" value="# infer transition matrix from state sequence&#10;# one state per row, states have to be integers beginning from 1&#10;inferTransitionMatrix = function(data) {&#10;&#9;numStates = length(levels(as.factor(data[,1])))&#10;&#9;transitionMatrix = matrix(0, nrow=numStates, ncol=numStates)&#10;&#9;for (i in 2:length(data[,1])) {&#10;&#9;&#9;transitionMatrix[data[,1][i-1],data[,1][i]] = transitionMatrix[data[,1][i-1],data[,1][i]] + 1&#10;&#9;}&#10;&#9;stateSums = apply(transitionMatrix,1,sum)&#10;&#9;zeroRows=which(stateSums==0)&#10;&#9;stateSums[stateSums==0]=-1&#10;&#9;transitionMatrix = transitionMatrix / stateSums&#10;&#9;transitionMatrix[zeroRows,]=1/numStates&#10;&#9;return(transitionMatrix)&#10;}&#10;&#10;# sample markov chain from transition matrix&#10;# beginning from initial state&#10;sampleFromTransitionMatrix = function(transitionMatrix, initialState, length) {&#10;&#9;numStates = dim(transitionMatrix)[1]&#10;&#9;samples = vector(length=length)&#10;&#9;samples[1] = initialState&#10;&#9;for (i in 2:length) {&#10;&#9;&#9;samples[i] = sample(1:numStates, size=1, replace=TRUE, prob=transitionMatrix[samples[i-1],])&#10;&#9;}&#10;&#9;return(samples)&#10;}&#10;&#10;# predict next state given a current state&#10;# by simply chosing the one with the highest transition probability&#10;predictNextState = function(transitionMatrix, currentState) {&#10;&#9;return(which.max(transitionMatrix[currentState,]))&#10;}&#10;&#10;transitionMatrix = inferTransitionMatrix(data)&#10;#sampleFromTransitionMatrix(transitionMatrix,1,20)&#10;#predictNextState(transitionMatrix, 2)"/>
        <enumeration key="inputs">
          <parameter key="name_of_variable" value="data"/>
        </enumeration>
        <list key="results">
          <parameter key="transitionMatrix" value="Generic R Result"/>
        </list>
      </operator>
      <operator activated="true" class="r:execute_script_r" compatibility="5.3.000" expanded="true" height="76" name="1st order markov transformation" width="90" x="313" y="30">
        <parameter key="script" value="# transform state series (one observation per line) into first order markov form&#10;# throws away first observation as it is not important for transition probs&#10;# that is:&#10;# 1&#9;&#9;1 -&#10;# 2&#9;&#9;1 2&#10;# 3  --&gt;&#9;3 2&#10;# 4&#9;&#9;4 3&#10;# 5&#9;&#9;5 4&#10;t1 = data&#10;t2 = data&#10;t3 = data&#10;for (i in 2:(dim(data)[1])) {&#10;&#9;t1[i,]=data[i-1,]&#10;}&#10;result = data.frame(data,t1)&#10;result = result[2:dim(data)[1],]&#10;names(result) = c(&quot;tn&quot;,&quot;tn-1&quot;)&#10;result.label = &quot;tn&quot;"/>
        <enumeration key="inputs">
          <parameter key="name_of_variable" value="data"/>
        </enumeration>
        <list key="results">
          <parameter key="result" value="Data Table"/>
        </list>
      </operator>
      <operator activated="true" class="naive_bayes" compatibility="5.3.005" expanded="true" height="76" name="Naive Bayes" width="90" x="581" y="30">
        <parameter key="laplace_correction" value="false"/>
      </operator>
      <connect from_op="Generate Data" from_port="output" to_op="Select Attributes" to_port="example set input"/>
      <connect from_op="Select Attributes" from_port="example set output" to_op="Numerical to Polynominal" to_port="example set input"/>
      <connect from_op="Numerical to Polynominal" from_port="example set output" to_op="Multiply" to_port="input"/>
      <connect from_op="Multiply" from_port="output 1" to_op="1st order markov transformation" to_port="input 1"/>
      <connect from_op="Multiply" from_port="output 3" to_op="Execute Script (R)" to_port="input 1"/>
      <connect from_op="Execute Script (R)" from_port="output 1" to_port="result 1"/>
      <connect from_op="1st order markov transformation" from_port="output 1" to_op="Naive Bayes" to_port="training set"/>
      <connect from_op="Naive Bayes" from_port="model" to_port="result 2"/>
      <connect from_op="Naive Bayes" from_port="exampleSet" to_port="result 3"/>
      <portSpacing port="source_input 1" spacing="0"/>
      <portSpacing port="sink_result 1" spacing="0"/>
      <portSpacing port="sink_result 2" spacing="0"/>
      <portSpacing port="sink_result 3" spacing="0"/>
      <portSpacing port="sink_result 4" spacing="0"/>
    </process>
  </operator>
</process>
